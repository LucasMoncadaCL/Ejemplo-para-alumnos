# Deconstrucción del esquema `tasks` (Postgres / Supabase) — explicada para alumnos que conocen Oracle 21c
 
> Nota: Este documento está pensado para estudiantes que sólo conocen
> Oracle Data Modeler y hacen consultas simples desde Oracle SQL Developer.
> Por eso las explicaciones incluyen equivalencias explícitas y pasos prácticos
> para que puedan aplicar lo aprendido sin asumir experiencia previa en Postgres.

SQL original (contexto Supabase/Postgres):

```sql
-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.

CREATE TABLE public.tasks (
  id bigint NOT NULL DEFAULT nextval('tasks_id_seq'::regclass),
  user_id uuid NOT NULL DEFAULT auth.uid(),
  titulo text NOT NULL,
  descripcion text,
  completada boolean NOT NULL DEFAULT false,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT tasks_pkey PRIMARY KEY (id),
  CONSTRAINT tasks_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
```

A continuación descompongo cada parte, explico qué hace en PostgreSQL/Supabase para que vean una equivalencia o nota sobre cómo se vería o comportaría en Oracle 21c.

---

## 1) `CREATE TABLE public.tasks (...)`

- `public` es el *schema* por defecto en PostgreSQL. Es equivalente a un *schema* en Oracle (owner/espacio de nombres).
- En Oracle normalmente crearías en un *schema* (por ejemplo `SCOTT.tasks`) o simplemente `CREATE TABLE tasks` si estás usando tu propio usuario.

Nota: Supabase crea además un esquema `auth` con tablas internas (`auth.users`) para gestión de usuarios — eso es específico de Supabase.

---

## 2) `id bigint NOT NULL DEFAULT nextval('tasks_id_seq'::regclass)`

- Qué hace (Postgres):
  - `id` es de tipo `bigint` (entero de 8 bytes), no nulo.
  - `DEFAULT nextval('tasks_id_seq'::regclass)` usa una *sequence* llamada `tasks_id_seq` para obtener el siguiente valor automático.
  - `::regclass` es una cast de texto a objeto de catálogo; aquí es solo una forma segura de referenciar la sequence.

- Supabase/Postgres específico:
  - En Postgres es habitual usar `bigserial` o `serial` que internamente crea la `sequence` y el `DEFAULT nextval(...)` automáticamente.

- Equivalente en Oracle 21c:
  - Oracle no tiene `serial` automático en la misma forma (hasta Oracle 12c se usaba `sequence` + `trigger`; desde Oracle 12c puedes usar `IDENTITY`):

```sql
-- Opción moderna (Oracle 12c+):
CREATE TABLE tasks (
  id NUMBER(19) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  ...
);

-- Opción clásica (sequence + trigger):
CREATE SEQUENCE tasks_id_seq START WITH 1 INCREMENT BY 1;
-- luego crear trigger que antes de insertar rellene :new.id desde la sequence
```

- Consejo para alumnos: `bigint` ~ `NUMBER(19)` en Oracle.

---

## 3) `user_id uuid NOT NULL DEFAULT auth.uid()`

- Qué hace (Postgres/Supabase):
  - `user_id` es de tipo `uuid` (Universally Unique Identifier) y no puede ser nulo.
  - `DEFAULT auth.uid()` es una expresión específica de Supabase/PostgREST que invoca la función `auth.uid()` en el contexto de una petición autenticada para asignar automáticamente el id del usuario conectado (según JWT).
  - Esto suele acompañarse de Row Level Security (RLS) en Supabase para que el DB aplique políticas por usuario.

- Supabase-specific: **`auth.uid()` es exclusivo de Supabase/PostgREST** (no es una función estándar de PostgreSQL). Devuelve el `sub` del JWT o el id del usuario autenticado.

- Equivalente en Oracle:
  - Oracle no tiene `auth.uid()`. Si quieres lograr lo mismo necesitarás que la aplicación (o un trigger) inserte el `user_id` desde el contexto de sesión, o usar una columna con valor por defecto proporcionado por la aplicación.
  - Alternativa: pasar el user_id desde el backend (FastAPI) en la query de inserción.

---

## 4) `titulo text NOT NULL, descripcion text`

- Postgres: `text` es tipo de longitud variable sin límite; ideal para strings largos.
- Oracle: usar `VARCHAR2(4000)` para strings cortos/medianos o `CLOB` para textos grandes.

Sugerencia práctica: si los títulos son pequeños, en Oracle `titulo VARCHAR2(255)` suele ser suficiente.

---

## 5) `completada boolean NOT NULL DEFAULT false`

- Postgres: existe el tipo `boolean` y `DEFAULT false` es directo.
- Oracle SQL: no existe tipo `BOOLEAN` en SQL (sí en PL/SQL). Normalmente en Oracle se modela como `NUMBER(1)` (0/1) o `CHAR(1)` ('Y'/'N').

Ejemplo Oracle:
```sql
completada NUMBER(1) DEFAULT 0 NOT NULL -- 0 = false, 1 = true
-- o
completada CHAR(1) DEFAULT 'N' NOT NULL
```

---

## 6) `created_at timestamp with time zone NOT NULL DEFAULT now(), updated_at timestamp with time zone NOT NULL DEFAULT now()`

- Postgres:
  - `timestamp with time zone` (abreviado `timestamptz`) almacena fecha-hora con zona y normaliza a UTC internamente.
  - `DEFAULT now()` inserta el timestamp actual (con zona) por defecto.

- Oracle:
  - Equivalente: `TIMESTAMP WITH TIME ZONE` o `TIMESTAMP WITH LOCAL TIME ZONE`.
  - Valor por defecto similar: `DEFAULT SYSTIMESTAMP` (o `CURRENT_TIMESTAMP`).

Ejemplo Oracle:
```sql
created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL
```

Nota importante: cuidado con la gestión de `updated_at` — normalmente se actualiza con un trigger `BEFORE UPDATE` para asignar `SYSTIMESTAMP` automáticamente.

---

## 7) `CONSTRAINT tasks_pkey PRIMARY KEY (id)`

- Igual en PostgreSQL y Oracle: define la clave primaria sobre `id`.
- En Oracle, si usas `IDENTITY` o `sequence+trigger`, la PK funciona igual.

---

## 8) `CONSTRAINT tasks_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)`

- Postgres/Supabase specifics:
  - Aquí se referencia `auth.users(id)` — `auth` es un schema de Supabase que contiene la tabla de usuarios administrada por Supabase Auth.
  - Es una práctica común en Supabase: la tabla `tasks` guarda `user_id` que referencia la tabla de usuarios provista por Supabase.

- En Oracle:
  - Deberías referenciar la tabla de usuarios correspondiente en tu schema (p.ej. `users(id)`), siempre que exista y sea consistente.

---

## Notas sobre RLS (Row Level Security) y `auth.uid()` — **Supabase específico**

- Supabase suele habilitar RLS para que solo los usuarios vean/alteren sus propias filas. Por ejemplo, una policy en Postgres podría ser:

```sql
-- Supabase example policy (Postgres)
CREATE POLICY "Users can access their tasks" ON public.tasks
FOR ALL
USING (user_id = auth.uid());
```

- Estas políticas y `auth.uid()` dependen del entorno PostgREST/Supabase. En Oracle no hay RLS exactamente igual; Oracle tiene Virtual Private Database (VPD) y Row-Level Security features (Oracle Label Security) pero su uso y sintaxis es distinto y más complejo.

---

## Traducción completa de ejemplo (versión Oracle aproximada)

A continuación una versión orientativa de cómo sería la tabla en Oracle (adaptada, no ejecutada aquí):

```sql
-- Versión orientativa para Oracle 21c
CREATE TABLE tasks (
  id NUMBER(19) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  user_id RAW(16) NOT NULL, -- si almacenas UUID binario, o VARCHAR2(36) si lo guardas como texto
  titulo VARCHAR2(255) NOT NULL,
  descripcion CLOB,
  completada NUMBER(1) DEFAULT 0 NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT tasks_pkey PRIMARY KEY (id)
);

-- Foreign key: asume que existe tabla users(id) en el schema correspondiente
ALTER TABLE tasks ADD CONSTRAINT tasks_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth_users(id);
```

Notas:
- `user_id` en Oracle puede modelarse como `RAW(16)` si quieres guardar el UUID en formato binario (más eficiente), o `VARCHAR2(36)` si prefieres el texto `xxxxxxxx-xxxx-...`.
- `auth_users` es un ejemplo; adapta al nombre real de la tabla de usuarios en Oracle.

---

## Puntos prácticos y recomendaciones para migración / compatibilidad

- Contraseñas y secretes: Supabase Auth se integra con la DB y genera `auth.users`. Si migras a Oracle deberás implementar tu propio sistema de autenticación o integrar un proveedor (Auth0, Cognito) y guardar la referencia del usuario.
- `auth.uid()` y RLS: en Postgres se usa para que la DB aplique políticas por usuario. En Oracle revisar VPD o aplicar la lógica a nivel de aplicación (FastAPI) para filtrar por `user_id`.
- Triggers para `updated_at`: en Postgres podrías usar `DEFAULT now()` en `created_at` y un trigger para `updated_at` o usar `generated always as` si aplica; en Oracle usar `BEFORE UPDATE` trigger para actualizar `updated_at`.
- Sequences y PK automáticas: en Oracle usa `IDENTITY` (12c+) o `sequence+trigger` (compatible con versiones más antiguas).
- Boolean: en Oracle modela como `NUMBER(1)` o `CHAR(1)`.

---

## Resumen — destacar lo que es específico de Postgres/Supabase

Marcar explícitamente las piezas que **no existen** en Oracle o que son específicas de Supabase/Postgres:

- `uuid` (tipo existe en Postgres; en Oracle usar `RAW(16)` o `VARCHAR2(36)`).
- `nextval('seq'::regclass)` y `bigserial` — Postgres sequences; Oracle usa `IDENTITY` o sequences + triggers.
- `timestamp with time zone` (`timestamptz`) — Oracle tiene `TIMESTAMP WITH TIME ZONE`, pero comportamiento y conversiones pueden diferir.
- `auth.uid()` — **Supabase-specific**: función que accede al contexto de la petición y devuelve el id del usuario desde JWT. No existe en Oracle.
- `auth.users` schema/table — parte del sistema de Supabase Auth.
- RLS + policies (`USING (user_id = auth.uid())`) — típico en Supabase/Postgres, distinto en Oracle.

---

## Usar Inteligencia Artificial para acelerar la migración Oracle → PostgreSQL (contexto: hackathon)

En un hackathon el tiempo es crítico. La IA (LLMs) puede acelerar pasos repetitivos y de conversión
entre dialectos SQL (Oracle → PostgreSQL). A continuación se explica cómo aprovecharla de forma
segura y práctica, qué pedirle y qué revisar manualmente.

1) Enfoque iterativo y seguro
  - No migres todo de una vez: elige 1-3 tablas críticas y migra esas primero.
  - Usa IA para generar DDL y scripts de transformación, pero siempre valida en un entorno de pruebas.
  - Time-box: fija bloques cortos (ej. 30–60 minutos) para que la IA produzca artefactos y luego prueba.

2) Qué pedirle a la IA (prompt patterns)
  - "Convierte este DDL de Oracle 21c a PostgreSQL, manteniendo constraints, índices y tipos equivalentes. Explica cambios que no sean directos." -> para DDL.
  - "Genera un script de migración de datos que use `pgloader` o COPY para cargar desde un dump de Oracle a PostgreSQL, incluyendo mapeo de tipos y manejo de UUID/timestamps." -> para datos.
  - "Convierte este trigger/procedimiento PL/SQL a una función PL/pgSQL o a un trigger en PostgreSQL y explica diferencias de comportamiento." -> para lógica en DB.

3) Plantilla de prompt (ejemplo)
  - Entrada: pega el DDL Oracle o porciones de código.
  - Prompt ejemplo:

```
Convierte este DDL Oracle a PostgreSQL 15. Mantén claves primarias y foráneas.
Explica cada línea que cambia y proporciona una versión alternativa si hay dos opciones.

DDL_ORACLE:
<pegar DDL>
```

4) Qué verificar manualmente (no delegar completamente a la IA)
  - Tipos de datos críticos: `NUMBER`, `DATE/TIMESTAMP`, `CLOB`, `BLOB`, `RAW(16)` → mapear correctamente.
  - Comportamiento de `IDENTITY` vs `sequence` y `nextval()` (valida valores actuales de sequences para evitar colisiones).
  - Triggers y procedimientos: la IA puede generar código, pero hay que testear lógica y rendimiento.
  - Constraints, índices y unicidad: comprobar que no se rompe la integridad referencial.

5) Herramientas combinadas con IA
  - `ora2pg` o `pgloader`: herramientas especializadas que hacen extracción/transformación; la IA puede ayudar a parametrizarlas o adaptar su output.
  - Scripts generados por IA que usan `COPY`/`psql`/`pg_restore` para cargar datos.

6) Ejemplo rápido de flujo en hackathon
  - Paso 1: Identificar tabla `tasks` y dependencias.
  - Paso 2: Pedir a la IA convertir DDL Oracle → PostgreSQL y revisar output (10–15 min).
  - Paso 3: Generar script de export/import para esa tabla (`pgloader` o CSV + COPY).
  - Paso 4: Ejecutar en DB de pruebas, correr tests automáticos o simples queries de validación.
  - Paso 5: Iterar sobre problemas (tipos, triggers, permisos) y actualizar prompts.

7) Prompts útiles para migración de datos
  - "Genera un comando `pgloader` que cargue la tabla `tasks` desde Oracle a PostgreSQL, mapeando `RAW(16)` a `uuid` y `NUMBER(1)` a `boolean`." 
  - "Devuélveme un `COPY` statement y la definición CSV header adecuada para los datos exportados desde Oracle." 

8) Riesgos y medidas de mitigación
  - La IA puede inventar funciones o comportamientos; siempre prueba en entorno aislado.
  - No confíes en la IA para secretos ni para decisiones de seguridad: revisar manualmente.
  - Automatiza pruebas mínimas (smoke tests) que validen conteo de filas, checksums y algunas filas aleatorias.

9) Checklist rápido para el equipo (hackathon)
  - [ ] Seleccionar tabla pequeña para la primera iteración.
  - [ ] Pedir a la IA la conversión del DDL y revisar diferencias.
  - [ ] Generar script de export/import y ejecutar en entorno de pruebas.
  - [ ] Validar integridad y tipos (5–10 queries de comprobación).
  - [ ] Documentar asunciones que la IA hizo (por ejemplo: mapeo `RAW(16)` → `uuid`).

10) Recursos y comandos útiles
  - `pgloader` (https://pgloader.io/) — excelente para migraciones de datos estructuradas.
  - `ora2pg` — herramienta para analizar y convertir esquemas Oracle a PostgreSQL.
  - Prompt template: guardar prompts efectivos en `docs/prompts_migration.md` para reutilizar.
